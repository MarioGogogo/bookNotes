(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{186:function(t,a,s){"use strict";s.r(a);var n=s(0),e=Object(n.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),s("p",[t._v("这篇文章旨在成为系列文章中的第一篇，旨在深入研究JavaScript及其实际工作方式：我们认为，通过了解JavaScript的构建基块以及它们如何一起发挥作用，您将能够编写更好的代码并应用。在构建SessionStack时，我们还将分享一些经验法则。SessionStack是一个轻量级的JavaScript应用程序，必须强大且高性能才能保持竞争力。\n如GitHut统计信息所示，就GitHub中的Active Repository和Total Pushs而言，JavaScript排名第一。它在其他类别中也没有落后很多。")]),t._v(" "),t._m(2),t._v(" "),s("p",[t._v("如果项目越来越依赖JavaScript，那么这意味着开发人员必须利用语言和生态系统提供的所有内容，并且对内部结构有越来越深入的了解，才能开发出出色的软件。\n事实证明，有很多开发人员每天都在使用JavaScript，但并不了解幕后情况。")]),t._v(" "),t._m(3),t._v(" "),s("p",[t._v("几乎每个人都已经听说过V8引擎是一个概念，而且大多数人都知道JavaScript是单线程的，或者它正在使用回调队列。\n在本文中，我们将详细介绍所有这些概念，并解释JavaScript实际如何运行。通过了解这些详细信息，您将能够编写更好地，无阻塞的应用程序，这些应用程序可以正确利用所提供的API。\n如果您不熟悉JavaScript，那么此博客文章将帮助您理解JavaScript与其他语言相比为何如此“古怪”。\n并且，如果您是一位经验丰富的JavaScript开发人员，那么希望它会为您提供每天使用的JavaScript运行时实际工作方式的一些新见解。")]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),s("p",[t._v("该引擎包括两个主要组件：\n*内存堆-这是发生内存分配的地方\n*调用堆栈-这是代码执行时堆栈帧的位置")]),t._v(" "),t._m(6),t._v(" "),s("p",[t._v("浏览器中有几乎所有JavaScript开发人员都已使用过的API（例如“ setTimeout”）。但是，引擎不提供这些API。\n那么，它们来自哪里？\n事实证明，现实有点复杂。")]),t._v(" "),t._m(7),t._v(" "),s("p",[t._v("因此，我们有引擎，但实际上还有更多。我们拥有由浏览器提供的称为Web API的东西，例如DOM，AJAX，setTimeout等。")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),s("p",[t._v("当引擎开始执行此代码时，调用堆栈将为空。之后，将执行以下步骤：")]),t._v(" "),t._m(12),t._v(" "),s("p",[t._v("调用堆栈中的每个条目都称为堆栈帧。\n这正是抛出异常时构造堆栈跟踪的方式-基本上，这是异常发生时调用堆栈的状态。看下面的代码：")]),t._v(" "),t._m(13),t._m(14),t._v(" "),s("p",[t._v("“ 炸毁堆栈 ” —当您达到最大呼叫堆栈大小时，就会发生这种情况。这很容易发生，特别是如果您使用递归而不对代码进行大量测试的话。看一下以下示例代码：")]),t._v(" "),t._m(15),t._m(16),t._v(" "),s("p",[t._v("但是，在某些时候，“调用堆栈”中的函数调用数量超出了“调用堆栈”的实际大小，浏览器决定通过抛出错误来采取措施，该错误看起来像这样：")]),t._v(" "),t._m(17),t._v(" "),s("p",[t._v("在单个线程上运行代码非常容易，因为您不必处理多线程环境中出现的复杂情况，例如死锁。\n但是在单线程上运行也有很大的限制。由于JavaScript具有单个调用堆栈，所以当事情变慢时会发生什么？")]),t._v(" "),t._m(18),t._v(" "),s("p",[t._v("当在调用堆栈中进行函数调用要花费大量时间才能处理时，会发生什么情况？例如，假设您想在浏览器中使用JavaScript进行一些复杂的图像转换。\n您可能会问-为什么这甚至是问题？问题在于，尽管调用堆栈具有要执行的功能，但浏览器实际上无法执行其他任何操作-它被阻塞了。这意味着浏览器无法渲染，无法运行任何其他代码，只是卡住了。如果您想要在应用程序中使用流畅的用户界面，则会产生问题。\n这不是唯一的问题。一旦您的浏览器开始处理“调用堆栈”中的许多任务，它可能会在很长一段时间内停止响应。而且大多数浏览器都会通过引发错误来采取行动，询问您是否要终止网页。")]),t._v(" "),t._m(19),t._v(" "),s("p",[t._v("现在，那不是最好的用户体验，不是吗？\n那么，如何在不阻塞UI并使浏览器无响应的情况下执行繁重的代码呢？好吧，解决方案是异步回调。\n这将在“ JavaScript的实际工作方式”教程的第2部分中进行详细说明："),s("a",{attrs:{href:"https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e",target:"_blank",rel:"noopener noreferrer"}},[t._v("“ V8引擎旁+ 5条有关编写优化代码的技巧 ”"),s("OutboundLink")],1),t._v("。")])])},[function(){var t=this.$createElement,a=this._self._c||t;return a("h1",{attrs:{id:"javascript的工作原理-引擎运行时和调用堆栈的概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript的工作原理-引擎运行时和调用堆栈的概述","aria-hidden":"true"}},[this._v("#")]),this._v(" JavaScript的工作原理:引擎运行时和调用堆栈的概述")])},function(){var t=this.$createElement,a=this._self._c||t;return a("blockquote",[a("p",[this._v("随着JavaScript越来越流行，团队正在其堆栈的各个级别上利用其支持-前端，后端，混合应用程序，嵌入式设备等等。")])])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[a("img",{attrs:{src:"http://book.52react.cn/20191030003151.png",alt:""}})])},function(){var t=this.$createElement,a=this._self._c||t;return a("h2",{attrs:{id:"总览"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总览","aria-hidden":"true"}},[this._v("#")]),this._v(" 总览")])},function(){var t=this.$createElement,a=this._self._c||t;return a("h3",{attrs:{id:"javascript引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript引擎","aria-hidden":"true"}},[this._v("#")]),this._v(" JavaScript引擎")])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[this._v("JavaScript引擎的一个流行示例是Google的V8引擎。例如，V8引擎用于Chrome和Node.js。这是它的外观的非常简化的视图：\n"),a("img",{attrs:{src:"http://book.52react.cn/20191030003259.png",alt:""}})])},function(){var t=this.$createElement,a=this._self._c||t;return a("h3",{attrs:{id:"运行时"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运行时","aria-hidden":"true"}},[this._v("#")]),this._v(" 运行时")])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[a("img",{attrs:{src:"http://book.52react.cn/20191030003336.png",alt:""}})])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[this._v("然后，我们有了非常流行的"),a("code",[this._v("事件循环")]),this._v("和"),a("code",[this._v("回调队列")]),this._v("。")])},function(){var t=this.$createElement,a=this._self._c||t;return a("h3",{attrs:{id:"调用堆栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用堆栈","aria-hidden":"true"}},[this._v("#")]),this._v(" 调用堆栈")])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[this._v("JavaScript是一种单线程编程语言，这意味着它具有单个调用堆栈。因此，它一次只能做一件事。\n"),a("strong",[this._v("调用堆栈是一种数据结构，它基本上记录我们在程序中的位置")]),this._v("。如果进入函数，则将其放在堆栈的顶部。如果我们从函数返回，则会弹出堆栈顶部。这就是堆栈所能做的。\n让我们来看一个例子。看下面的代码：")])},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("multiply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printSquare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("multiply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printSquare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[a("img",{attrs:{src:"http://book.52react.cn/20191030003525.png",alt:""}})])},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" foo（）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    抛出新错误（"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'SessionStack将帮助您解决崩溃问题:)'")]),t._v("）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v("  bar（）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    foo（）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v("  start（）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    bar（）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \nstart（）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[a("img",{attrs:{src:"http://book.52react.cn/20191030004338.png",alt:""}}),this._v("\n如果在Chrome中执行此操作（假设此代码位于名为foo.js的文件中），则会生成以下堆栈跟踪：\n"),a("img",{attrs:{src:"http://book.52react.cn/20191030003714.png",alt:""}})])},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" foo（）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    foo（）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \nfoo（）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[a("img",{attrs:{src:"http://book.52react.cn/20191030003844.png",alt:""}}),this._v("\n当引擎开始执行此代码时，它首先调用函数“ foo”。但是，此函数是递归的，并且在没有任何终止条件的情况下开始调用自身。因此，在执行的每个步骤中，都将相同的函数一遍又一遍地添加到调用堆栈中。看起来像这样：\n"),a("img",{attrs:{src:"http://book.52react.cn/20191030003907.png",alt:""}})])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[a("img",{attrs:{src:"http://book.52react.cn/20191030003941.png",alt:""}})])},function(){var t=this.$createElement,a=this._self._c||t;return a("h3",{attrs:{id:"并发与事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发与事件循环","aria-hidden":"true"}},[this._v("#")]),this._v(" 并发与事件循环")])},function(){var t=this.$createElement,a=this._self._c||t;return a("p",[a("img",{attrs:{src:"http://book.52react.cn/20191030004031.png",alt:""}})])}],!1,null,null,null);a.default=e.exports}}]);